# --------------------------------------------------#
# Scientific computing
# ICTP/Serrapilheira 2022
# Biodiversity Databases
# First version 2022-07-27
# jfb
# --------------------------------------------------#


##### Libs #####
library(rgbif)
library(Taxonstand)
library(CoordinateCleaner)
library(maps)
library(dplyr)
library(tidyr)
##### Data #####
species <- "Myrsine coriacea"
occs <- occ_search(scientificName = species,
                   limit = 100000) #in DwC standard
names(occs)
#glimpse(occs)
#names(occs$data)
myrsine.data <- occs$data
write.csv(myrsine.data, # export the data
          "data/raw/myrsine_data.csv",
          row.names = FALSE)

colnames(myrsine.data)

##### Check Taxonomy #####

# check unique entries for the species
sort(unique(myrsine.data$scientificName))
# In this particular case, we have a species with a long history of synonyms. In the gbif data, there is already a column showing the currently accepted taxonomy:
table(myrsine.data$taxonomicStatus)

# We can also check which of the names are accepted or not:
table(myrsine.data$scientificName, myrsine.data$taxonomicStatus)

# Let’s use the function TPL() from package Taxonstand to check if the taxonomic updates in the gbif data are correct. This function receives a vector containing a list of species and performs both orthographical and nomenclature checking. Nomenclature checking follows The Plant List (http://www.theplantlist.org/).

# We will first generate a list with unique species names and combine it to the data. This is preferable because we do not need to check more than once the same name and, in the case of working with several species, it will make the workflow faster.
species.names <- unique(myrsine.data$scientificName)
dim(species.names)

tax.check <- TPL(species.names) # check if the taxonomic updates in the gbif data are correct

# Note that the function adds several new variables to the input data and creates columns such as New.Genus and New.Species with the accepted name. We should adopt these names if the column New.Taxonomic.status is filled with “Accepted”
# We will merge the new genus and species and then add them to the original data.
# creating new object w/ original and new names after TPL
new.tax <- data.frame(scientificName = species.names,
                      genus.new.TPL = tax.check$New.Genus,
                      species.new.TPL = tax.check$New.Species,
                      status.TPL = tax.check$Taxonomic.status,
                      scientificName.new.TPL = paste(tax.check$New.Genus,
                                                     tax.check$New.Species))
# now we are merging raw data and checked data
myrsine.new.tax <- merge(myrsine.data, new.tax, by = "scientificName")

# Exporting data after taxonomy check
write.csv(myrsine.new.tax,
          "data/processed/data_taxonomy_check.csv",
          row.names = FALSE)

##### Check Coordinates #####

# First, let’s inspect visually the coordinates in the raw data.

plot(decimalLatitude ~ decimalLongitude, data = myrsine.data, asp = 1)
map(, , , add = TRUE) #warning but it works

# Now we will use the the function clean_coordinates() from the CoordinateCleaner package to clean the species records. NAs are not accepted so we will first select only data that have a numerical value for both latitude and longitude

# Note: at this moment having a specific ID code for each observation is essential. The raw data already provides an ID in the column gbifID.

myrsine.coord <- myrsine.data[!is.na(myrsine.data$decimalLatitude)
                              & !is.na(myrsine.data$decimalLongitude),]

# output w/ only potential correct coordinates
geo.clean <- clean_coordinates(x = myrsine.coord,
                               lon = "decimalLongitude",
                               lat = "decimalLatitude",
                               species = "species",
                               value = "clean")

# Plot side by side to compare raw and clean data
par(mfrow = c(1, 2))
plot(decimalLatitude ~ decimalLongitude, data = myrsine.data, asp = 1)
map(, , , add = TRUE) #ignore the warning
plot(decimalLatitude ~ decimalLongitude, data = geo.clean, asp = 1)
map(, , , add = TRUE) #ignore the warning

par(mfrow = c(1, 1))

# When setting value = clean it returns only the potentially correct coordinates. For checking and reproducibility we want to save all the output with the flags generated by the routine. Let’s try a different output.

myrsine.new.geo <- clean_coordinates(x = myrsine.coord,
                                     lon = "decimalLongitude",
                                     lat = "decimalLatitude",
                                     species = "species",
                                     value = "spatialvalid")

# Then, we merge the raw data with the cleaned data.
myrsine.new.geo2 <- merge(myrsine.data, myrsine.new.geo,
                          all.x = TRUE,
                          by = "key")

plot(decimalLatitude ~ decimalLongitude, data = myrsine.new.geo, asp = 1)
map(, , , add = TRUE)

# Exporting the data after coordinate check
write.csv(myrsine.new.geo2,
          "data/processed/myrsine_coordinate_check.csv",
          row.names = FALSE)


#### For Fun ####
library(raster)
library(tmap)
library(mapview)
sp <- drop_na(myrsine.new.geo2,decimalLatitude.x,decimalLongitude.x)


spraw <- myrsine.data %>% filter(decimalLatitude <= 90,decimalLatitude >= -90,decimalLongitude <= 90,decimalLongitude >= -90)
spraw <- as_tibble(spraw)
coordinates(spraw) <- ~decimalLongitude + decimalLatitude
proj4string(spraw) <- projection(raster())

spclean <- geo.clean %>% filter(decimalLatitude <= 90,decimalLatitude >= -90,decimalLongitude <= 90,decimalLongitude >= -90)
spclean <- as_tibble(spclean)
coordinates(spclean) <- ~decimalLongitude + decimalLatitude
proj4string(spclean) <- projection(raster())

# Mapview
mapview(list(spclean,spraw),col.regions=list("red","blue"),col=list("red","blue"))

# Tmap - still trying to figure this out

raw_sf <- sf::st_as_sf(spraw)
clean_sf <- sf::st_as_sf(spclean)

data("World")
tm_shape(World) +
  tm_borders() +
  tm_dots(raw_sf, col = 'red') +
  tm_dots(clean_sf, col = 'blue')
